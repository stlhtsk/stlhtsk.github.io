<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>겨울 배경 미소년 애니메이션</title>

  <!-- 파비콘 추가 (기존 유지) -->
  <link rel="icon" type="image/png" href="파비콘.png" />

  <style>
    /* 기본 HTML, BODY 스타일 - 너가 요청한 겨울 분위기 그라데이션 배경으로 변경 */
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden; /* 스크롤바 숨기기 */
      font-family: 'Arial', sans-serif;
      color: #333; /* 글씨 색상 조정 (흰 배경에 대비되게) */
      text-align: center;
      position: relative;
    }

    body {
      /* 흰색, 연한 하늘색 그라데이션 (겨울 분위기) */
      background: linear-gradient(135deg, #e0f2f7 0%, #ffffff 50%, #e0f2f7 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      box-sizing: border-box;
      padding: 20px;
    }

    /* 파티클 캔버스 스타일 (기존 유지, z-index만 조정) */
    canvas#particle-canvas {
      position: fixed; /* 화면에 고정 */
      top: 0; left: 0;
      width: 100vw; height: 100vh; /* 뷰포트 전체 크기 */
      z-index: 0; /* 모든 콘텐츠보다 뒤에 위치 */
      pointer-events: none; /* 마우스 이벤트 무시 */
      display: block;
    }

    /* 크로마키 비디오/캔버스 컨테이너 */
    .video-chromakey-container {
      position: relative;
      width: 640px; /* 원하는 비디오 너비 */
      height: 360px; /* 원하는 비디오 높이 (16:9 비율 예시) */
      max-width: 90vw; /* 화면 너비에 따라 반응형 조절 */
      max-height: 90vh; /* 화면 높이에 따라 반응형 조절 */
      overflow: hidden; /* 혹시 모를 오버플로우 방지 */
      z-index: 10; /* 배경보다 앞에 위치 */
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.2); /* 입체감 효과 */
      border-radius: 10px; /* 부드러운 모서리 */
    }

    /* 비디오 요소 자체는 화면에 보이지 않게 하고 캔버스에 그릴 것 */
    #mi_sonyeon_video {
      display: none;
    }

    /* 크로마키 결과가 그려질 캔버스 */
    #chromakey_canvas {
      width: 100%;
      height: 100%;
      display: block;
      background-color: transparent; /* 초기 배경 투명 */
    }
  </style>
</head>
<body>

  <!-- 흰 파티클을 그릴 캔버스 -->
  <canvas id="particle-canvas"></canvas>

  <!-- 크로마키 비디오/캔버스 컨테이너 -->
  <div class="video-chromakey-container">
    <!-- 초록색 배경의 미소년 동영상이 로드될 비디오 태그 -->
    <video id="mi_sonyeon_video" src="미소년 동영상.mp4" preload="auto" loop muted autoplay></video>
    <!-- 크로마키 처리된 미소년 동영상이 그려질 캔버스 -->
    <canvas id="chromakey_canvas"></canvas>
  </div>

  <script>
    // ⭐️ 파티클 JavaScript (새로 추가)
    const particleCanvas = document.getElementById('particle-canvas');
    const particleCtx = particleCanvas.getContext('2d');
    let particles = [];
    const particleCount = 100;
    const particleColor = 'rgba(255, 255, 255, 0.7)'; // 흰색 파티클

    function resizeParticleCanvas() {
      particleCanvas.width = window.innerWidth;
      particleCanvas.height = window.innerHeight;
      particles = [];
      for (let i = 0; i < particleCount; i++) {
        particles.push(new Particle());
      }
    }
    window.addEventListener('resize', resizeParticleCanvas);
    resizeParticleCanvas();

    function Particle() {
      this.x = Math.random() * particleCanvas.width;
      this.y = Math.random() * particleCanvas.height;
      this.size = Math.random() * 2 + 1; // 1 to 3
      this.speedX = Math.random() * 0.5 - 0.25; // -0.25 to 0.25
      this.speedY = Math.random() * 1.5 + 0.5; // 0.5 to 2 (아래로 흐르는 느낌)
    }

    Particle.prototype.update = function() {
      this.x += this.speedX;
      this.y += this.speedY;

      if (this.y > particleCanvas.height) { // 아래로 사라지면 위에서 다시 나타남
        this.y = -this.size;
        this.x = Math.random() * particleCanvas.width;
      }
      if (this.x > particleCanvas.width || this.x < -this.size) { // 좌우 경계 넘어가면 다시 나타남
        this.x = Math.random() * particleCanvas.width;
      }
    };

    Particle.prototype.draw = function() {
      particleCtx.fillStyle = particleColor;
      particleCtx.beginPath();
      particleCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      particleCtx.fill();
    };

    function animateParticles() {
      particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
      for (let i = 0; i < particles.length; i++) {
        particles[i].update();
        particles[i].draw();
      }
      requestAnimationFrame(animateParticles);
    }
    animateParticles();

    // ⭐️ 크로마키 JavaScript (새로 추가)
    const video = document.getElementById('mi_sonyeon_video');
    const chromakeyCanvas = document.getElementById('chromakey_canvas');
    const chromakeyCtx = chromakeyCanvas.getContext('2d', { willReadFrequently: true }); // 성능 최적화

    let isVideoPlaying = false; // 비디오 재생 상태 추적

    video.addEventListener('loadedmetadata', () => {
      // 비디오 메타데이터 로드 후 캔버스 크기 설정
      chromakeyCanvas.width = video.videoWidth;
      chromakeyCanvas.height = video.videoHeight;
      // 비디오가 컨테이너에 맞춰지도록 스타일 업데이트 (이 부분은 CSS로 처리될 수 있음)
      // video-chromakey-container의 width/height와 같도록 설정
      document.querySelector('.video-chromakey-container').style.width = `${video.videoWidth}px`;
      document.querySelector('.video-chromakey-container').style.height = `${video.videoHeight}px`;
    });

    video.addEventListener('play', () => {
      isVideoPlaying = true;
      drawFrame(); // 비디오 재생 시작 시 프레임 그리기 시작
    });

    video.addEventListener('pause', () => {
      isVideoPlaying = false;
    });
    video.addEventListener('ended', () => {
      isVideoPlaying = false;
    });

    // 초록색 배경 감지 및 제거 함수 (임계값 조정 가능)
    function processFrame() {
      if (!isVideoPlaying || video.paused || video.ended) {
        return;
      }

      // 캔버스에 비디오 프레임 그리기
      chromakeyCtx.drawImage(video, 0, 0, chromakeyCanvas.width, chromakeyCanvas.height);

      // 픽셀 데이터 가져오기
      let frame = chromakeyCtx.getImageData(0, 0, chromakeyCanvas.width, chromakeyCanvas.height);
      let l = frame.data.length / 4;

      // 크로마키 색상 (초록색 범위) 정의
      // 이 값들을 조절하여 원하는 초록색 배경을 더 잘 제거할 수 있어
      const keyColor = { r: 0, g: 255, b: 0 }; // 순수한 초록색 (기준)
      const threshold = 100; // 초록색으로 간주할 오차 범위 (0-255)
      const similarity = 0.5; // 색상 유사성 (0-1, 높을수록 엄격)
      const smooth = 0.1; // 가장자리 부드럽게 (0-1)

      for (let i = 0; i < l; i++) {
        let r = frame.data[i * 4 + 0];
        let g = frame.data[i * 4 + 1];
        let b = frame.data[i * 4 + 2];

        // 색상 간의 거리 계산
        let dist = Math.sqrt(
          (r - keyColor.r) * (r - keyColor.r) +
          (g - keyColor.g) * (g - keyColor.g) +
          (b - keyColor.b) * (b - keyColor.b)
        );

        // 만약 색상이 초록색 범위에 있다면 투명하게 처리
        if (g > r && g > b && g > threshold && dist < 150) { // g 값이 r,b보다 높고 특정 임계값 이상이면 초록색으로 간주
          // 단순 투명 처리 대신 좀 더 부드럽게 처리
          let factor = Math.min(dist / threshold, 1);
          frame.data[i * 4 + 3] = 255 * factor; // 알파값 조정
        } else {
           frame.data[i * 4 + 3] = 255; // 아니면 불투명
        }
      }
      chromakeyCtx.putImageData(frame, 0, 0);

      // 다음 프레임 그리기 요청
      if (isVideoPlaying) {
        requestAnimationFrame(processFrame);
      }
    }

    // 비디오가 재생 준비되면 자동 재생 시작 시도
    video.addEventListener('canplay', () => {
      video.play().catch(error => {
        // 자동 재생 실패 시 (예: 브라우저 정책) 사용자에게 재생 버튼 표시 등
        console.log("Autoplay was prevented:", error);
        // 사용자에게 비디오 재생을 요청하는 UI를 보여줄 수 있어
        // 예: 재생 버튼을 만들어 클릭 시 video.play() 실행
      });
    });

    // 페이지 로드 후 처음 한 번 drawFrame 호출
    function drawFrame() {
        if (isVideoPlaying) {
            processFrame();
        } else {
            requestAnimationFrame(drawFrame); // 재생 대기
        }
    }

  </script>
</body>
</html>
